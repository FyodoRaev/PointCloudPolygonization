
##### 1. формат, среда, метрики

Моя задача — создать прототип, который можно будет быстро интегрировать в Metashape. Это диктует следующий подход:
1. **Основная разработка — вне Metashape.** Использовать Metashape Python API для каждой итерации медленно и неудобно. 
    - **Формат данных:** **LAZ/LAS** — это промышленный стандарт. Он компактен и поддерживает классы точек. Используй библиотеку `laspy` или `pdal` в Python для чтения/записи.
    - **Прототипирование:** Скрипт принимает на вход `.laz` файл и выдает на выходе векторное представление (например, в GeoJSON, DXF или простом OBJ).
    - **Библиотеки для прототипирования:** `open3d` или `pyntcloud` (для базовых операций с облаками, таких как RANSAC, кластеризация).[2](https://habr.com/ru/companies/itmai/articles/549716/)



    - **Соответствие нормалей:** Угловое отклонение между нормалями, вычисленными по точкам, и нормалями полученных плоскостей.
- **Топологическая корректность:** Модель должна быть "водонепроницаемой" (watertight), без дыр, самопересечений. Скаты крыши должны корректно соединяться на коньках и ребрах.
- **Производительность:** Время обработки одного здания. В тикете есть примеры таймингов — это ориентир.
- **Робастность:** Алгоритм не должен падать на сложных крышах, зданиях с растительностью на крыше, при разной плотности точек.

---

- **GlobalMapper & Vadstena:**
    1. **Классификация точек** 
    2. **Детекция плоскостей:** На точках класса "здания" ищется доминирующая плоскость (или несколько)
    3. **Сегментация:** Точки группируются по принадлежности к найденным плоскостям
    4. **Векторизация:** Сегменты аппроксимируются полигонами, которые затем "сшиваются" для формирования модели крыши.
    
    - **Инженерный трюк:** Vadstena, скорее всего, использует библиотеку параметрических моделей крыш (двускатная, вальмовая и т.д.). После нахождения основных плоскостей система пытается подобрать наиболее подходящий шаблон и подогнать его параметры. Это упрощает реконструкцию, но ограничивает ее типовыми формами.
- **Efficient RANSAC for Point-Cloud Shape Detection:** Это ключевая статья для оптимизации.
    
    - **Проблема:** Стандартный RANSAC выбирает точки для построения модели (например, 3 точки для плоскости) абсолютно случайно.[3](https://ru.wikipedia.org/wiki/RANSAC) В плотном облаке вероятность выбрать 3 точки, лежащие на одной небольшой плоскости крыши, крайне мала. Это требует огромного числа итераций.
    - **Решение (инженерный трюк):** Использовать локальные свойства точек для "умной" выборки. Перед запуском RANSAC для каждой точки можно посчитать нормаль (например, по `k` ближайшим соседям). При поиске плоскости RANSAC должен выбирать не три случайные точки из всего облака, а три точки с близкими по направлению нормалями. Это на порядки сокращает пространство поиска и ускоряет сходимость.
- **3DBAG/roofer/City3D:** 
    - **Ключевая идея:** Использование **2D контура здания (footprint)** в качестве мощнейшего априорного знания. Это меняет постановку задачи с "найти здания и их форму" на "зная, где находится здание, восстановить его крышу".
Контур здания — это проекция внешних стен на горизонтальную плоскость.
Стены здания строятся как вертикальные плоскости, "выдавленные" вверх от ребер 2D-контура. Крыша "ложится" сверху на эти стены. Без контура непонятно, где заканчивается крыша и начинаются стены.
    - **Алгоритм `roofer`:**
        1. **Фильтрация:** Берутся только точки облака, находящиеся внутри 2D-контура здания.
        2. **Детекция плоскостей:** В отфильтрованном облаке ищутся плоскости (скорее всего, методом region growing или RANSAC).
        3. **Детекция линий:** Плоскости пересекаются для нахождения ребер и коньков. Дополнительно края сегментов плоскостей аппроксимируются линиями (используются альфа-шейпы).
        4. **Регуляризация:** Линии кластеризуются по ориентации (например, все почти параллельные линии становятся строго параллельными). Это исправляет мелкие ошибки и делает геометрию "чистой".
        5. **Построение 2D-графа:** Регуляризованные линии проецируются на 2D-плоскость и формируют разбиение исходного контура на полигоны (фейсы).
        6. **Оптимизация (Graph-cut):** Самый сложный этап. Каждому 2D-фейсу из разбиения нужно присвоить одну из найденных 3D-плоскостей. Это формулируется как задача минимизации энергии, где "стоимость" зависит от того, насколько хорошо точки над фейсом ложатся на присвоенную плоскость, и от "гладкости" — штрафа за соседние фейсы с разными плоскостями.
        7. **Экструзия:** Финальное 2D-разбиение с присвоенными 3D-плоскостями "выдавливается" в 3D-модель.

---


**Стратегия A (предпочтительная, если есть контуры):** Подход **3DBAG/roofer**.

- **Обоснование:** Это наиболее робастный и точный путь, если у вас есть или вы можете получить 2D-контуры зданий (например, из кадастровой карты, OSM или даже путем полуавтоматической векторизации). Он отсекает главную проблему — сегментацию отдельных зданий и сильно ограничивает область поиска плоскостей. Это прямой путь к качественному LoD2.
- **Перспективы:** Высокие. Алгоритм сложен, но дает отличный результат и имеет открытую реализацию (`roofer`), которую можно изучить.

**Стратегия B (если контуров нет):** Комбинированный подход.

- **Обоснование:** Если 2D-контуров нет, тебе придется сначала выделить отдельные здания.
- **Шаги:**
    1. **Кластеризация:** На точках класса "здания" запустить алгоритм пространственной кластеризации (например, DBSCAN) для разделения их на отдельные строения.
    2. **Генерация "грубого" контура:** Для каждого кластера найти его 2D-ограничивающий прямоугольник (bounding box) или выпуклую оболочку (convex hull). Это будет твой "footprint".
    3. **Применение урезанного подхода `roofer`:** Использовать этот грубый контур для фильтрации точек и последующего поиска плоскостей с помощью **Efficient RANSAC**.
    4. **Реконструкция:** Сшивать найденные плоскости. Здесь можно обойтись без сложного Graph-cut, а использовать более простые эвристики или библиотеку параметрических моделей крыш (как в Vadstena).

**"Efficient RANSAC" — это не стратегия, а ключевой инструмент, который должен быть ядром этапа поиска плоскостей в любой из стратегий.**

---

**Этап 1: Реализация ядра по Стратегии А (с контурами)**

1. **Задача:** Реализовать поиск плоскостей крыши для одного здания.
2. **Действия:**
    - Написать Python-скрипт, который:
        - Читает один полигон-контур из `footprints.geojson`.
        - Читает все точки из `output.laz`.
        - Отфильтровывает точки, оставляя только те, что внутри полигона.
        - **Реализует Efficient RANSAC:**
            - Для начала можно использовать `open3d.geometry.PointCloud.segment_plane()`.[2](https://habr.com/ru/companies/itmai/articles/549716/) Это стандартный RANSAC.
            - Затем оптимизировать его: перед вызовом `segment_plane` оценить нормали (`estimate_normals`), отфильтровать точки с вертикальными нормалями (стены) и передать в RANSAC только "точки крыши". Это уже даст прирост.
            - _Для продвинутого уровня:_ реализовать свою логику RANSAC, где выборка кандидатов происходит на основе схожести нормалей.
        - Повторять RANSAC, пока в оставшихся точках находятся плоскости достаточного размера.
3. **Результат:** Скрипт, который для одного здания выдает список уравнений найденных плоскостей и наборы точек, им принадлежащие. Визуализируй результат в `open3d`, раскрашивая точки каждой плоскости в свой цвет.

**Этап 2: Полигонизация и сборка модели**

1. **Задача:** Из набора плоскостей собрать 3D-модель крыши.
2. **Действия:**
    - Это самая сложная часть с точки зрения вычислительной геометрии.
    - **Простой путь:** Найти попарные пересечения плоскостей (линии ребер и коньков). Найти пересечения этих линий с вертикальными "стенами", построенными по контуру. Попытаться из этих вершин собрать полигоны. Библиотека `shapely` может помочь с 2D-операциями, `scipy.spatial` — с 3D.
    - **Правильный путь:** Изучить, как это делает `roofer` (этап "Initial roof-partition" и "Graph-cut"). Попытаться реализовать упрощенную версию. Например, вместо Graph-cut для каждого 2D-фейса просто выбирать ту 3D-плоскость, которой соответствует наибольшее число точек над этим фейсом.
3. **Результат:** Скрипт, генерирующий `.obj` файл с 3D-моделью крыши.

**Перспективы по другим объектам:**

- **Деревья:** Задача проще. После кластеризации точек класса "растительность" для каждого кластера можно найти самую нижнюю точку (основание ствола) и аппроксимировать крону простым примитивом (сфера, эллипсоид).
- **ЛЭП:** Задача сложнее. Требует поиска столбов (RANSAC для цилиндров), а затем аппроксимации проводов между ними цепной линией (катенария). Это отдельный большой подпроект.

